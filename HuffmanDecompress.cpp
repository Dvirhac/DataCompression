/*
 * Decompression application using static Huffman coding
 *
 * Usage: HuffmanDecompress InputFile OutputFile
 * This decompresses files generated by the "HuffmanCompress" application.
 *
 * Copyright (c) Project Nayuki
 *
 * https://www.nayuki.io/page/reference-huffman-coding
 * https://github.com/nayuki/Reference-Huffman-coding
 */

#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <limits>
#include <vector>
#include <sstream>
#include "BitIoStream.hpp"
#include "CanonicalCode.hpp"
#include "FrequencyTable.hpp"
#include "HuffmanCoder.hpp"
#include "math.h"
#define NUM_OF_STRINGS 64
using std::uint32_t;
using namespace std;

int main(int argc, char *argv[]) {

    //////////////////////GENERATE THE VECTOR OF VECTORS/////////////////

    ifstream strings("/home/dvir/CLionProjects/dvir-pro/strings.txt", ios:: in|ios::binary);
    string line;
    std::vector<std::vector<uint32_t >> words_to_int;
    std :: vector<int> words_freqs;
    while (std :: getline(strings,line))
    {
        string code_word = line;
        std :: getline(strings, line);
        std :: stringstream num(line);
        int freq = 0;
        num >> freq;
        std :: vector<uint32_t> chars_as_int;
        for (const char &character : code_word){
            chars_as_int.push_back((int)character);
        }
        words_to_int.push_back(chars_as_int);
        words_freqs.push_back(freq);
    }


    // Handle command line arguments
    /*if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " InputFile OutputFile" << std::endl;
        return EXIT_FAILURE;
    }
    const char *inputFile  = "/home/dvir/CLionProjects/huffman 3/binaryCoded";
    const char outputFile = "/home/dvir/CLionProjects/huffman 3/binaryDecoded";*/

    const char *inputFile  = "/home/dvir/CLionProjects/dvir-pro/Files/BSTCompress";
    const char *outputFile = "/home/dvir/CLionProjects/dvir-pro/Files/BSTV2.out";

    // Perform file decompression



    std::ifstream in(inputFile, std::ios::binary);
    std::ofstream out(outputFile, std::ios::binary);
    BitInputStream bin(in);
    try {

        // Read code length table
        std::vector<uint32_t> codeLengths;
        for (int i = 0; i < 321 + NUM_OF_STRINGS + 1; i++) {
            // For this file format, we read 8 bits in big endian
            uint32_t val = 0;
            for (int j = 0; j < 8; j++)
                val = (val << 1) | bin.readNoEof();
            codeLengths.push_back(val);
            // std::cout << std::endl;
        }
        const CanonicalCode canonCode(codeLengths);
        const CodeTree code = canonCode.toCodeTree();

        HuffmanDecoder dec(bin);
        dec.codeTree = &code;
        while (true) {
            uint32_t symbol = dec.read();
            if (symbol == 256)  // EOF symbol
                break;
            int b = static_cast<int>(symbol);
            std::cout << b << " ";
            /*   if (std::numeric_limits<char>::is_signed)
                   b -= (b >> 7) << 8;
               std::cout << b << std::endl;*/
            if (b < 257)
                out.put(static_cast<char>(b));

            else if (b > 256 && b < 322) {
                int dif = b - 256;
                int sum = pow(2,dif);
                for (int i = 0 ; i < sum ; i ++)
                    out.put(0);
            }
            else
            {
                int index = b-322;
                std :: vector<uint32_t> vec = words_to_int[index];
                for (unsigned int i : vec){
                    out.put(static_cast<char>(i));
                }

            }

        }
        return EXIT_SUCCESS;

    } catch (const char *msg) {
        std::cerr << msg << std::endl;
        return EXIT_FAILURE;
    }
}